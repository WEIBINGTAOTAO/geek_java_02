
一、串行GC 和 并行GC
    1、串行GC
        所谓的Serial GC，串行GC是jvm里最简单最原始的垃圾回收策略
        可以通过jvm参数 -XX: +UseSerialGC 使用它
        对年轻代使用 mark-corp（标记-复制）算法，对老年代使用mark-sweep-compact（标记-清除-整理）算法。
        对年轻代和老年代进行垃圾都会触发STW，停止所有的应用线程。 
        由于是单线程的垃圾回收器，不能进行并行处理，所以不管有多少cpu内核，jvm在垃圾收集的时候都只能使用单个核心，适合几百MB堆内存的jvm。如果堆内容较大，由于是单线程，处理效率低，那STW的时间就会特别长。

 
    2、并行GC
        Parallel GC ,是JDK678的默认GC。java 9 以及之后的版本，默认GC是G1 GC
        使用 -XX:+UseParallelGC 或者 -XX:+UseParalledOldGC 或者两者一起配置   -XX:+UseParallelGC  -XX:+UseParalledOldGC，可以启用并行GC。
        对年轻代使用mark-corp（标记-复制）算法，对老年代使用mark-sweep-compact（标记-清除-整理）算法。
        年轻代和老年代进行垃圾回收都会触发STW。
        多线程垃圾回收器，使用-XX:ParalledGCThreads=N来控制GC线程数，默认为CUP核心数
        适用于多核服务器，主要目标是增加吞吐量。在GC期间，所有CPU内核都在并行进行垃圾回收，所有总的暂停时间更短。在没有进行GC时，所有线程都被用来运行业务处理。

二、CMS GC
    
    Mostly Comcurrent Mark and Sweep Garbage Collector，最大可能性的并发的标记清除垃圾回收算法
    使用 -XX:+UseConcMarkSweepGC 启动此GC
    对年轻代使用对串行算法改进的ParNew(缩写，是指Parallel 年轻代)的GC算法，采用并行的mark-corp（标记-复制）算法，会导致并行的STW。对老年代使用并发的mark-sweep（标记-清除）算法，这里没有整理阶段。
    CMS设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段
        1、不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。
        2、在标记清除阶段的大部分工作和应用线程一起并发执行，尽可能避免应用线程的暂停。
    所以是尽最大可能的并发。
    默认情况下，cms使用的并发线程数等于CPU的1/4。
    如果服务器是多核CPU，并且主要调优目标是降低GC停顿导致的系统研制，那么使用CMS是个明智的选择。
    在老年代进行并发回收时，可能会伴随多次年轻代的minorGC.
    优点：在减少停顿时间上做了很多复杂而有用的工作，用于垃圾回收的并发线程执行的同时，不需要暂停应用线程。
    缺点：老年代内存没有整理，在某些情况下，GC会造成不可预测的暂停时间，特别是堆内存较大的情况下。



三、G1 GC   

    G1 GC 可以看做CMS GC 的改造，G1的全称是Garbage-First，意思是垃圾优先，哪一块的垃圾最多就优先清理它。
    使用参数 -XX:+UseG1GC 启动G1 GC .
    G1 GC 最主要的设计目标是：将STW停顿的时间和分布，变成可预期且可配置的。可以使用参数-XX:MaxGCPauseMillis=50 控制预期GC暂停的时间，默认是200毫秒。
    G1 GC 堆不再分年轻代和老年代，而是划分为多个（通常是2048个）小块：Region。每个小块，可能一会被定义为Eden区，一会被指定为Surivivor区或者Old区。这样划分后，使得不必每次都收集整理整个堆内存，而是每次只处理一部分内存块。
    每次GC暂停都会收集所有年轻代的内存块，但一般只包含部分老年代的内存块。
    在并发阶段会估算每个小块中存活对象的数量，垃圾最多的小块会被优先收集。

G1 GC参数

-XX:G1NewSizePercent：初始年轻代占整个堆内存的大小，默认是5%
-XX:G1MaxNewSizePercent：最大年轻代占整个堆内存的大小，默认是60%
-XX:G1HeapRegionSize：设置每个Region的大小，单位MB，需要为 1 2 4 8 16 32 中的某个值，默认是堆内存的1/2000，如果这个值设置的比较大，那么大对象就可以进入Region了
-XX:ConcGCThreads ：与Java应用一起执行的GC线程数量，默认是Java线程的1/4，减少这个参数的数值，可能会提升并行回收的效率，提高系统内部吞吐量。如果这个数值过低，参数回收垃圾的线程不足，会导致并行回收机制耗时加长。
-XX:+InitiatingHeapOccupancyPercent（简称IHOP）：G1内部并行回收循环启动的阈值，默认是堆内存的45%。这个可以理解为老年代使用大于等于45%的时候，JVM会启动垃圾回收，决定了在什么时候启动老年代的并行回收。
-XX:G1HeapWastePercent：G1停止回收的最小内存大小，默认是堆内存的5%。GC回收所有的Region中的对象，如果需要回收的内存小于5%，就会停下来不再收集。
-XX:+GCTimeRatio：这个参数就是计算花在Java应用线程上和花在GC线程上的时间比率，默认是9。

G1 GC 注意事项

在某些情况下G1触发了FullGC，这时G1会退化使用Serial 收集器来完成垃圾的清理工作，由于仅仅使用单线程来完成GC工作，所有GC暂停时间会很长达到秒级。

1、并发模式失败
G1 启动标记周期，但是在Mix GC之前，老年代就会填满，这个时候G1就会放弃标记周期。
解决方法：增加堆内存大小，或者调整周期（例如增加线程数_XX:ConcGCThreads等）。

2、晋升失败
没有足够的内存工存活对象或晋升对象使用，由此触发了Full GC
解决办法：
    a)  增加-XX:G1ReservePercent选项的值增加预留内存大小（同时会增加总的堆大小）
    b) 减少-XX:InitiatingHeapOccupancyPercent提前启动标记周期
    c) 通过增加-XX:ConcGcThreads选项来增加并行标记线程的数量

3、巨型对象分配失败
当巨型对象找不到合适的空间进行分配时，就会启动Full GC ,来释放空间
解决方法：增加对内存，或者增大-XX:G1HeapRegionSize


四、不同堆大小对垃圾回收效率的影响

  1、如果增加堆内存大小，那么会减少GC暂停的次数，但是由于每次回收的对象大小变多，会增加GC暂停的时间。
  2、如果减少堆内存大小，那么会增加GC暂停的次数，减少GC暂停的时间，但是可能会出现内存溢出、G1退化为Serial策略等问题。




    









        
    
